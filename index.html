<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="The best time to plant a tree was twenty years ago. The second-best time is now.">
<meta property="og:type" content="website">
<meta property="og:title" content="Cpa To Coder">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Cpa To Coder">
<meta property="og:description" content="The best time to plant a tree was twenty years ago. The second-best time is now.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Johnson CHEN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Cpa To Coder</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Cpa To Coder</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">前端算法面试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 15:34:03" itemprop="dateCreated datePublished" datetime="2021-05-09T15:34:03+08:00">2021-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-11 00:18:55" itemprop="dateModified" datetime="2021-05-11T00:18:55+08:00">2021-05-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><p><strong>1、map 方法和forEach区别</strong></p>
<blockquote>
<p>map 方法在调用形式上与 forEach 无异，区别在于 map 方法会根据你传入的函数逻辑对数组中每个元素进行处理、进而返回一个全新的数组。</p>
</blockquote>
<p>2、fill在填充二维数组时的问题</p>
<p>当你给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用。也就是说下图中虽然看似我们给7个坑位各初始化了一个数组：</p>
<blockquote>
<p>其实这7个数组对应了同一个引用、指向的是同一块内存空间，它们本质上是同一个数组。因此当你修改第0行第0个元素的值时，第1-6行的第0个元素的值也都会跟着发生改变。</p>
</blockquote>
<blockquote>
<p>本着安全的原则，这里我推荐大家采纳的二维数组初始化方法非常简单（而且性能也不错）。直接用一个 for 循环来解决：</p>
</blockquote>
<p>JS比较特别。如果我们在一个数组中只定义了一种类型的元素，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>它是一个纯数字数组，那么对应的确实是连续内存。</p>
<p>但如果我们定义了不同类型的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;haha&#x27;</span>, <span class="number">1</span>, &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的。</p>
<p>说起来有点绕口，但大家谨记“JS 数组未必是真正的数组”即可。</p>
<p><strong>链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。</strong></p>
<p><strong>3、数组的应用</strong></p>
<p>大家以后做算法题的时候，要有这样的一种本能：当发现自己的代码里有两层循环时，先反思一下，能不能用空间换时间，把它优化成一层循环。</p>
<blockquote>
<p>因为两层循环很多情况下都意味着 <code>O(n^2)</code> 的复杂度，这个复杂度非常容易导致你的算法超时。即便没有超时，在明明有一层遍历解法的情况下，你写了两层遍历，面试官对你的印象分会大打折扣。</p>
</blockquote>
<p><strong>空间换时间，Map 来帮忙</strong></p>
<p>拿我们这道题来说，其实二层遍历是完全不必要的。</p>
<blockquote>
<p>大家记住一个结论：几乎所有的求和问题，都可以转化为求差问题。 这道题就是一个典型的例子，通过把求和问题转化为求差问题，事情会变得更加简单。</p>
</blockquote>
<p>（这里大家相信已经能察觉出来双指针法的使用场景了，一方面，它可以做到空间换时间；另一方面，它也可以帮我们降低问题的复杂度。）</p>
<blockquote>
<p>双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。因此这道题的第一步是将数组排序：</p>
</blockquote>
<p><strong>什么时候你需要联想到对撞指针？</strong></p>
<p>这里我给大家两个关键字——“有序”和“数组”。</p>
<p>没错，见到这两个关键字，立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！</p>
<p>即便数组题目中并没有直接给出“有序”这个关键条件，我们在发觉普通思路走不下去的时候，也应该及时地尝试手动对其进行排序试试看有没有新的切入点——没有条件，创造条件也要上。</p>
<h2 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h2><p>在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS 中的链表，是以嵌套的对象的形式来实现的：</p>
<p>在涉及链表删除操作的题目中，重点不是定位目标结点，而是定位目标结点的前驱结点。做题时，完全可以只使用一个指针（引用），这个指针用来定位目标结点的前驱结点。</p>
<blockquote>
<p>删除的标准是：在链表的遍历过程中，无法再遍历到某个结点的存在。按照这个标准，要想遍历不到 node3，我们直接让它的前驱结点 node1 的 next 指针跳过它、指向 node3 的后继即可</p>
</blockquote>
<p><img src="%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95.assets/fc6a1f482c0c4b24bf791171c43167d9~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<p>如此一来，node3 就成为了一个完全不可抵达的结点了，它会被 JS 的垃圾回收器自动回收掉。</p>
<p>如果说在命题时，数组和字符串的角色往往是“算法思想的载体”，那么链表本身就可以被认为是“命题的目的”。单在真题归纳解读环节，我们能讲的技巧、能做的题目已经有很多。结合实际面试中的命题规律，我把这些题目分为以下三类：</p>
<ul>
<li>链表的处理：合并、删除等（删除操作画个记号，重点中的重点！）</li>
<li>链表的反转及其衍生题目</li>
<li>链表成环问题及其衍生题目</li>
</ul>
<p><strong>思路分析</strong></p>
<blockquote>
<p>做链表处理类问题，大家要把握住一个中心思想——处理链表的本质，是处理链表结点之间的指针关系。</p>
</blockquote>
<p>其实在链表题中，经常会遇到这样的问题：链表的第一个结点，因为没有前驱结点，导致我们面对它无从下手。这时我们就可以用一个 dummy 结点来解决这个问题。 所谓 dummy 结点，就是咱们人为制造出来的第一个结点的前驱结点，这样链表中所有的结点都能确保有一个前驱结点，也就都能够用同样的逻辑来处理了。 dummy 结点能够帮助我们降低链表处理过程的复杂度，处理链表时，不设 dummy 结点思路可能会打不开；设了 dummy 结点的话，就算不一定用得上，也不会出错。所以笔者个人非常喜欢用 dummy 结点。有心的同学可能也会注意到，在本节的第一题“链表的合并”中，其实也有 dummy 结点的身影。</p>
<p><a target="_blank" rel="noopener" href="http://interview.poetries.top/algorithm-interview/note/09-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%9A%E6%8C%87%E9%92%88%E2%80%94%E2%80%94%E7%8E%A9%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%A4%8D%E6%9D%82%E6%93%8D%E4%BD%9C.html#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%9A%E6%8C%87%E9%92%88">#</a><strong>快慢指针与多指针</strong></p>
<p>链表题目中，有一类会涉及到反复的遍历。涉及反复遍历的题目，题目本身虽然不会直接跟你说“你好，我是一道需要反复遍历的题目”，但只要你尝试用常规的思路分析它，你会发现它一定涉及反复遍历；同时，涉及反复遍历的题目，还有一个更明显的特征，就是它们往往会涉及相对复杂的链表操作，比如反转、指定位置的删除等等。</p>
<blockquote>
<p>解决这类问题，我们用到的是双指针中的“快慢指针”。快慢指针指的是两个一前一后的指针，两个指针往同一个方向走，只是一个快一个慢。快慢指针严格来说只能有俩，不过实际做题中，可能会出现一前、一中、一后的三个指针，这种超过两个指针的解题方法也叫“多指针法”。</p>
</blockquote>
<p>快慢指针+多指针，双管齐下，可以帮助我们解决链表中的大部分复杂操作问题。</p>
<h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><p><strong>二叉树是指满足以下要求的树：</strong></p>
<ul>
<li>它可以没有根结点，作为一棵空树存在</li>
<li>如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。如下图：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/6/1714e6b275ab6309?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<blockquote>
<p>注意，二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。</p>
</blockquote>
<h3 id="二叉树的编码实现"><a href="#二叉树的编码实现" class="headerlink" title="#二叉树的编码实现"></a><a target="_blank" rel="noopener" href="http://interview.poetries.top/algorithm-interview/note/03-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%8E%8C%E6%8F%A1%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BC%96%E7%A0%81%E5%AE%9E%E7%8E%B0">#</a>二叉树的编码实现</h3><blockquote>
<p>在 JS 中，二叉树使用对象来定义。它的结构分为三块：</p>
</blockquote>
<ul>
<li>数据域</li>
<li>左侧子结点（左子树根结点）的引用</li>
<li>右侧子结点（右子树根结点）的引用</li>
</ul>
<blockquote>
<p>在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：</p>
</blockquote>
<h2 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h2><blockquote>
<p>同时，回文字符串还有另一个特性：如果从中间位置“劈开”，那么两边的两个子串在内容上是完全对称的。因此我们也可以结合对称性来做判断：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存字符串的长度</span></span><br><span class="line">    <span class="keyword">const</span> len = str.length</span><br><span class="line">    <span class="comment">// 遍历前半部分，判断和后半部分是否对称</span></span><br><span class="line">    <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++</span>)</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">str[i]!==str[len-i-<span class="number">1</span>]</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（谨记这个对称的特性，非常容易用到）</p>
<p>如何判断自己解决回文类问题的解法是否“高效”？其中一个很重要的标准，<strong>就是看你对回文字符串的对称特性利用得是否彻底。</strong></p>
<p>字符串题干中若有“回文”关键字，那么做题时脑海中一定要冒出两个关键字——对称性 和 双指针。这两个工具一起上，足以解决大部分的回文字符串衍生问题。</p>
<p>回到这道题上来，我们首先是初始化两个指针，一个指向字符串头部，另一个指向尾部：</p>
<blockquote>
<p>什么是捕获组？其实就是正则表达式中被小括号括住的部分。在这道题里，我们需要从字符串中提取的其实只有“+/-”符号以及其后面的数字而已，同时这个字符串需要满足 可能存在的空格+正负号+数字字符串+其它字符内容 这样的格式才算合法，那我们就可以通过这样写正则表达式，实现“匹配”和“提取”的双重目的：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\s*([-\+]?[0-9]*).*/</span><br></pre></td></tr></table></figure>

<p>针对正则基础比较薄弱的同学，我来解释一下上面这个正则表达式：</p>
<ul>
<li>首先，<code>\s</code> 这个符号，意味着空字符，它可以用来匹配回车、空格、换行等空白区域，这里，它用来被匹配空格。<em>这个符号，跟在其它符号后面，意味着“前面这个符号可以出现0次或多次。\s</em>，这里的意思就是空格出现0次或多次，都可被匹配到。</li>
<li>接着 <code>()</code> 出现了。<code>()</code> 圈住的内容，就是我们要捕获起来额外存储的东西。</li>
<li><code>[]</code>中的匹配符之间是“或”的关系，也就是说只要能匹配上其中一个就行了。这里<code>[]</code>中包括了<code>-</code>和<code>\+</code>，<code>-</code>不必说匹配的是对应字符，这个<code>\+</code>之所以加了一个斜杠符，是<code>-</code> 因为<code>+</code>本身是一个有特殊作用的正则匹配符，这里我们要让它回归<code>+</code>字符的本义，所以要用一个<code>\</code>来完成转义。</li>
<li><code>[0-9]*</code>结合咱们前面铺陈的知识，这个就不难理解了，它的意思是 <code>0-9</code> 之间的整数，能匹配到0个或多个就算匹配成功。</li>
<li>最后的 <code>.</code>这个是任意字符的意思，<code>.*</code>用于字符串尾部匹配非数字的任意字符。我们看到<code>.*</code>是被排除捕获组之外的，所以说这个东西其实也不会被额外存储，它被“摘除”了。</li>
</ul>
<p>JS 的正则相关方法中， test()方法返回的是一个布尔值，单纯判断“是否匹配”。要想获取匹配的结果，我们需要调度match()方法：</p>
<p>match() 方法是一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。</p>
<p>如果我们的正则表达式尾部有 g 标志，match()会返回与完整正则表达式匹配的所有结果，但不会返回捕获组。</p>
<p>这里我们没有使用g标志，match()就会返回第一个完整匹配（作为数组的第0项）及其相关的捕获组（作为数组的第1及第1+项）。</p>
<p>这里我们只定义了一个捕获组，因此可以从 groups[1] 里拿到我们捕获的结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-18 23:18:34 / 修改时间：23:19:05" itemprop="dateCreated datePublished" datetime="2021-01-18T23:18:34+08:00">2021-01-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="一、限定符"><a href="#一、限定符" class="headerlink" title="一、限定符"></a>一、限定符</h3><h4 id="1、？"><a href="#1、？" class="headerlink" title="1、？"></a>1、？</h4><ul>
<li>限定符，表示它前面这个字符d需要出现0次或者一次</li>
<li>通俗来说，就是？前的字符可有可无<h4 id="2、"><a href="#2、" class="headerlink" title="2、*"></a>2、*</h4></li>
<li>限定符，表示会匹配0个或者多个字符</li>
</ul>
<h4 id="3、"><a href="#3、" class="headerlink" title="3、+"></a>3、+</h4><ul>
<li>限定符，表示会匹配出现1次以上的字符</li>
</ul>
<h4 id="4、-x-y"><a href="#4、-x-y" class="headerlink" title="4、{x, y}"></a>4、{x, y}</h4><ul>
<li>限定符，表示字符出现次数为x到y次</li>
</ul>
<h4 id="5、（）"><a href="#5、（）" class="headerlink" title="5、（）"></a>5、（）</h4><ul>
<li>用（）限定字符组合，其余用法同单个字符</li>
</ul>
<h3 id="二、“或”运算"><a href="#二、“或”运算" class="headerlink" title="二、“或”运算"></a>二、“或”运算</h3><p>a  (cat | dog)  匹配  a cat 或者 a dog， 括号必不可少</p>
<h3 id="三-、字符类"><a href="#三-、字符类" class="headerlink" title="三 、字符类"></a>三 、字符类</h3><p>[abc]+ 方括号里面的内容代表要求匹配的字符只能取自它们<br>[a-z]代表所有的小写英文字符<br>[a-zA-Z]代表所有的英文字符<br>[a-zA-Z0-9]代表所有的英文字符和数字<br>[^0-9] 代表所有的非数字字符（包括换行符）</p>
<h3 id="四、元字符"><a href="#四、元字符" class="headerlink" title="四、元字符"></a>四、元字符</h3><p>\d  数字字符<br>\w 单词字符,即所有的英文字符、数字及下划线<br>\s 空白符，包含Tab和换行符<br>\b 代表边界<br>\D 非数字字符<br>\W 非单词字符<br>\S 非空白字符<br>.  代表任意字符，但不包含换行符<br>^匹配行首<br>$匹配行尾</p>
<h3 id="五、贪婪与懒惰匹配"><a href="#五、贪婪与懒惰匹配" class="headerlink" title="五、贪婪与懒惰匹配"></a>五、贪婪与懒惰匹配</h3><ul>
<li>&lt;.+ &gt;  默认贪婪匹配“任意字符”</li>
<li>&lt;.+ ?&gt;  ?会将默认的贪婪匹配切换为懒惰匹配</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/25/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/25/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">红宝书学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-25 17:28:36" itemprop="dateCreated datePublished" datetime="2020-11-25T17:28:36+08:00">2020-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-29 16:42:39" itemprop="dateModified" datetime="2021-04-29T16:42:39+08:00">2021-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-this-用法及相关原理"><a href="#1-this-用法及相关原理" class="headerlink" title="1. this 用法及相关原理"></a>1. this 用法及相关原理</h2><ul>
<li><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><ul>
<li>全局环境，默认绑定到window</li>
</ul>
</li>
</ul>
<ul>
<li><p>函数独立调用的时候，this默认绑定到window</p>
<ul>
<li>被嵌套的函数独立调用时，this默认绑定到window</li>
</ul>
</li>
<li><p>立即执行的函数this是window</p>
<ul>
<li>闭包的this默认绑定到window</li>
</ul>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><ul>
<li>被直接对象所包含的函数调用时，也称为方法调用，this隐式绑定到该直接对象</li>
</ul>
<h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><ul>
<li>通过call()、apply()、bind()方法把对象绑定到this上，叫做显式绑定。对于被调用的函数来说，叫做间接调用</li>
</ul>
<h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><ul>
<li>如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><strong>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</strong></p>
<ul>
<li><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。</p>
</li>
<li><p><img src="%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0.assets/image-20201126121355727.png" alt="image-20201126121355727"></p>
</li>
<li><p>从上面四个结果不难看出:</p>
<p>call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：</p>
<p>call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 **obj.myFun.call(db,’成都’, … ,’string’ )**。</p>
<p>apply 的所有参数都必须放在一个数组里面传进去 **obj.myFun.apply(db,[‘成都’, …, ‘string’ ])**。</p>
<p>bind 除了返回是函数以外，它 的参数和 call 一样。</p>
<p>当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！</p>
<h2 id="2-原型-原型链"><a href="#2-原型-原型链" class="headerlink" title="2.原型/原型链"></a>2.原型/原型链</h2></li>
</ul>
</li>
</ul>
<ul>
<li><img src="%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0.assets/image-20201125233301189.png" alt="image-20201125233301189"></li>
<li><img src="%E7%BA%A2%E5%AE%9D%E4%B9%A6%E5%AD%A6%E4%B9%A0.assets/image-20201125233418970.png" alt="image-20201125233418970"></li>
<li>实例中的指针仅指向原型，而不指向构造函数</li>
</ul>
<h2 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h2><ul>
<li>作用域链本质上是一个指向 变量对象的指针列表，它只引用但不实际包含变量对象。</li>
<li>匿名函数（拉姆达函数）：创建一个函数并将它赋值给变量，因为function关键字后面没有标识符。匿名函数的name属性是空字符串。</li>
</ul>
<h2 id="4-面向对象相关"><a href="#4-面向对象相关" class="headerlink" title="4.面向对象相关"></a>4.面向对象相关</h2><ul>
<li>面向对象三大特征 ： 封装  继承  多态</li>
</ul>
<h2 id="5、箭头函数"><a href="#5、箭头函数" class="headerlink" title="5、箭头函数"></a>5、箭头函数</h2><p>在JS种有两种函数，一种是普通函数，另一种是箭头函数。每个普通函数都是<br>Function的实例，而箭头函数不是任何类的实例，每次调用都是不一样的引用。那我们只需要<br>处理普通函数的情况，箭头函数直接返回它本身就好了。<br>那么如何来区分两者呢？</p>
<p>答案是: 利用原型。箭头函数是不存在原型的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/23/react%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/react%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">react学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-23 23:47:57" itemprop="dateCreated datePublished" datetime="2020-11-23T23:47:57+08:00">2020-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 17:19:08" itemprop="dateModified" datetime="2021-04-23T17:19:08+08:00">2021-04-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="一、几组概念："><a href="#一、几组概念：" class="headerlink" title="一、几组概念："></a>一、几组概念：</h3><h4 id="1-库和框架"><a href="#1-库和框架" class="headerlink" title="1. 库和框架"></a>1. 库和框架</h4><ul>
<li>library（库）：小而巧，只提供特定API。优点是船小好调头 很容易在库之间切换但不会改变代码</li>
<li>Framework（框架）：大而全，提供一整套解决方案，切换比较困难</li>
</ul>
<h4 id="2-模块化和组件化"><a href="#2-模块化和组件化" class="headerlink" title="2.模块化和组件化"></a>2.模块化和组件化</h4><ul>
<li>模块化：从代码角度分析，把可复用代码，抽离为单个模块，便于项目的维护和开发；</li>
<li>组件化：从UI界面角度分析，把一些可复用的UI元素，抽离为单独的组件</li>
</ul>
<h4 id="3-虚拟DOM和DIFF算法"><a href="#3-虚拟DOM和DIFF算法" class="headerlink" title="3. 虚拟DOM和DIFF算法"></a>3. 虚拟DOM和DIFF算法</h4><ul>
<li>虚拟DOM：用JS对象的形式来模拟页面上DOM的嵌套关系，目的是为了实现页面元素的高效更新。</li>
<li>tree diff / component diff / element diff，最小化页面重绘</li>
</ul>
<h4 id="4-单页APP（SPA）的挑战"><a href="#4-单页APP（SPA）的挑战" class="headerlink" title="4.单页APP（SPA）的挑战"></a>4.单页APP（SPA）的挑战</h4><ul>
<li><p>如何保持数据与UI同步更新</p>
</li>
<li><p>如何提高DOM操作效率</p>
</li>
<li><p>使用HTML开发UI界面异常复杂</p>
</li>
<li><h3 id="二、主体内容："><a href="#二、主体内容：" class="headerlink" title="二、主体内容："></a>二、主体内容：</h3><h4 id="1-bind（this）"><a href="#1-bind（this）" class="headerlink" title="1.bind（this）"></a>1.bind（this）</h4></li>
</ul>
<p>新添加方法内部的this默认不是组件对象，而是undefined，所以需要bind强制绑定，</p>
<p>所以组件中实际使用的方法是bind返回的新方法。</p>
<p><img src="react%E5%AD%A6%E4%B9%A0.assets/image-20201126145254334.png" alt="image-20201126145254334"></p>
<p><img src="react%E5%AD%A6%E4%B9%A0.assets/image-20201126145332493.png" alt="image-20201126145332493"></p>
<h4 id="2-生命周期函数"><a href="#2-生命周期函数" class="headerlink" title="2.生命周期函数"></a>2.生命周期函数</h4><ul>
<li><p>函数列表<br>componentWillMount :  在组件渲染之前执行</p>
<p>componentDidMount : 在组件渲染之后执行 ，开启监听，发送ajax请求</p>
<p>shouldComponentUpdate: 返回true和false， true代表允许改变，false代表不允许改变</p>
<p>componentWillUpdate: 数据在改变之前执行（state，props）</p>
<p>componentDidUpdate: 数据修改完成（state，props）</p>
<p>componentWillReveiceProps: props发生改变执行</p>
<p>componentWillUnmount: 组件卸载前执行，收尾工作，如清理定时器。</p>
</li>
</ul>
<h4 id="3-setState更新是同步还是异步"><a href="#3-setState更新是同步还是异步" class="headerlink" title="3.setState更新是同步还是异步"></a>3.setState更新是同步还是异步</h4><ul>
<li><p>setState 会引起视图的重绘</p>
</li>
<li><p>在可控的情况下异步，在非可控的情况下同步</p>
</li>
<li><p>key的作用在于减少重复绘制；</p>
</li>
</ul>
<h4 id="4-React面向组件编程"><a href="#4-React面向组件编程" class="headerlink" title="4.React面向组件编程"></a>4.React面向组件编程</h4><ul>
<li><p>工厂函数组件（简单组件）：没有状态，效率高</p>
</li>
<li><p>ES6类组件（复杂组件）</p>
</li>
<li><p>数据保存在哪个组件内？看数据是某个组件需要，还是某些组件需要（给共同的父组件）</p>
<p>子组件不能直接改变父组件的状态。状态在哪个组件，更新状态的行为就应该定义在哪</p>
</li>
<li><p>组件化编写功能的流程</p>
<p>1、拆分组件</p>
<p>2、实现静态组件（只有静态界面，没有动态数据和交互）</p>
<p>3、实现动态组件  1）实现初始化数据动态显示  2）实现交互功能</p>
</li>
</ul>
<h4 id="5-兄弟组件或者跨代通信"><a href="#5-兄弟组件或者跨代通信" class="headerlink" title="5.兄弟组件或者跨代通信"></a>5.兄弟组件或者跨代通信</h4><p>使用消息订阅和发布机制<br>工具库：PubSubJS</p>
<h4 id="6-如何编写路由效果"><a href="#6-如何编写路由效果" class="headerlink" title="6.如何编写路由效果"></a>6.如何编写路由效果</h4><p>1、编写路由组件<br>2、在父路由组件中指定路由链接（<NavLink>）和路由(<Route>)</p>
<h4 id="7-redux"><a href="#7-redux" class="headerlink" title="7.redux"></a>7.redux</h4><ul>
<li>React中，状态数据，state；组件与组件之间可以传递数据：props、回传事件</li>
<li>状态管理的js库，不是react插件库</li>
<li>降低耦合度，一般使用react-redux，使用Provider组件和connect方法</li>
<li>如果你不知道什么时候需要使用Redux,就是你不需要使用它，当你遇到解决不了的问题，自然会想起Redux</li>
<li>异步中间件redux-thunk</li>
<li>三大原则之一： State是只读的，唯一改变state的方法是触发action, action是一个用于描述已发生事件的普通对象</li>
<li><img src="react%E5%AD%A6%E4%B9%A0.assets/image-20210205101723438.png" alt="image-20210205101723438"></li>
</ul>
<h4 id="8-符号"><a href="#8-符号" class="headerlink" title="8.符号"></a>8.符号</h4><ul>
<li><p>&lt;&gt;代表XML语法</p>
</li>
<li><p>{}代表js语法</p>
</li>
<li><p>（）代表存在标签结构，并且标签结构要换行</p>
</li>
</ul>
<h4 id="9-key"><a href="#9-key" class="headerlink" title="9. key"></a>9. key</h4><ul>
<li>key代表唯一索引，只有发生变化的部分才会重绘，节约资源</li>
</ul>
<h4 id="10-受控组件和非受控组件"><a href="#10-受控组件和非受控组件" class="headerlink" title="10 受控组件和非受控组件"></a>10 受控组件和非受控组件</h4><ul>
<li><p>受控组件，如input中的value需要通过state中的value属性来管理，改变值同时需要onChange事件和setState来实现（e.target.value）</p>
</li>
<li><p>非受控组件 通过React.createRef和this.myRef.current来获取对象</p>
<h4 id="11、-按需加载antd"><a href="#11、-按需加载antd" class="headerlink" title="11、 按需加载antd"></a>11、 按需加载antd</h4><p>安装babel-plugin-import完成按需加载，优化加载速度</p>
<h4 id="11、post的ajax和fetch区别"><a href="#11、post的ajax和fetch区别" class="headerlink" title="11、post的ajax和fetch区别"></a>11、post的ajax和fetch区别</h4></li>
<li><p>ajax：对象类型的参数</p>
</li>
<li><p>body：字符串类型的参数，可以用queryString进行转换</p>
</li>
</ul>
<h4 id="12、跨域"><a href="#12、跨域" class="headerlink" title="12、跨域"></a>12、跨域</h4><ul>
<li> 开发模式：1、看cra的git文档<a target="_blank" rel="noopener" href="https://github.com/facebook/create-react-app/blob/master/docusaurus/docs/proxying-api-requests-in-development.md">https://github.com/facebook/create-react-app/blob/master/docusaurus/docs/proxying-api-requests-in-development.md</a>   在package.json中加入proxy；2、安装http-proxy-middleware</li>
<li>生产模式：jsonp、cors、postMessage、iframe</li>
</ul>
<h4 id="13、router"><a href="#13、router" class="headerlink" title="13、router"></a>13、router</h4><ul>
<li>exact匹配规则</li>
<li> switch保证只出现一个页面</li>
</ul>
<h4 id="14、component和PureComponent"><a href="#14、component和PureComponent" class="headerlink" title="14、component和PureComponent"></a>14、component和PureComponent</h4><ul>
<li>component不会对数据进行比较</li>
<li>PureComponent 对数据进行浅比较props</li>
</ul>
<h4 id="15、高阶组件"><a href="#15、高阶组件" class="headerlink" title="15、高阶组件"></a>15、高阶组件</h4><ul>
<li>函数、参数是一个组件、返回值也是组件</li>
</ul>
<h4 id="16、Navlink和Link的区别"><a href="#16、Navlink和Link的区别" class="headerlink" title="16、Navlink和Link的区别"></a>16、Navlink和Link的区别</h4><ul>
<li>NavLink可以高亮显示</li>
</ul>
<h4 id="17、bind"><a href="#17、bind" class="headerlink" title="17、bind"></a>17、bind</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span onClick=&#123;<span class="built_in">this</span>.clickHandler.bind(<span class="built_in">this</span>, <span class="string">&#x27;北京&#x27;</span>)&#125;&gt;北京&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>bind可以传递参数</p>
<h4 id="18、token"><a href="#18、token" class="headerlink" title="18、token"></a>18、token</h4><p><img src="react%E5%AD%A6%E4%B9%A0.assets/image-20210222113459456.png" alt="image-20210222113459456"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/IDE%E5%BF%AB%E6%8D%B7%E9%94%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/IDE%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="post-title-link" itemprop="url">IDE快捷键</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-21 14:54:15" itemprop="dateCreated datePublished" datetime="2020-11-21T14:54:15+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-05 19:42:03" itemprop="dateModified" datetime="2021-02-05T19:42:03+08:00">2021-02-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Webstorm"><a href="#Webstorm" class="headerlink" title="Webstorm"></a>Webstorm</h3><ol>
<li><p>alt + j 选择多个同名变量并修改</p>
</li>
<li><p>ctrl+ r 批量替换</p>
</li>
<li><p>删除光标所在行代码 idea快捷键: Ctrl+X </p>
</li>
<li><p>(1)<strong>选择当前行</strong></p>
<p>按Home（定位到行首）然后按Shift+Dnd（行尾）<br>或者<br>按End(定位到行尾)然后按Shift+Home<br>或者<br>按Home（定位到行首）然后按Shift+↓</p>
<p><strong>(2).选中多行</strong></p>
<p>按Home（定位到行首）然后按Ctrl+Shift+Dnd（行尾）<br>或者<br>按End(定位到行尾)然后按Ctrl+Shift+Home<br>或者<br>按Home（定位到行首）然后按Shift+↓(多按一下Shift+↓则多选一行)</p>
<p>注:当前行行首：Home<br>当前行行尾：End<br>当前文档首行：ctrl+Home<br>当前文档尾行：ctrl+End</p>
</li>
</ol>
<h3 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h3><p>1、ctrl+shift+k 删除当前行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/16/%E5%87%BD%E6%95%B0%E5%A4%87%E5%BF%98%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/16/%E5%87%BD%E6%95%B0%E5%A4%87%E5%BF%98%E5%BD%95/" class="post-title-link" itemprop="url">函数备忘录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-16 23:16:20" itemprop="dateCreated datePublished" datetime="2020-11-16T23:16:20+08:00">2020-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-07 20:44:12" itemprop="dateModified" datetime="2020-12-07T20:44:12+08:00">2020-12-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-slice"><a href="#1-slice" class="headerlink" title="1. slice"></a>1. slice</h2><h3 id="1-1JavaScript-Array-slice-方法"><a href="#1-1JavaScript-Array-slice-方法" class="headerlink" title="1.1JavaScript Array slice() 方法"></a>1.1JavaScript Array slice() 方法</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><em>array</em>.slice(<em>start</em>, <em>end</em>)</p>
<h4 id="参数-Values"><a href="#参数-Values" class="headerlink" title="参数 Values"></a>参数 Values</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>start</em></td>
<td align="left">可选。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。</td>
</tr>
<tr>
<td align="left"><em>end</em></td>
<td align="left">可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。</td>
</tr>
</tbody></table>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Array</td>
<td align="left">返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</td>
</tr>
</tbody></table>
<h3 id="1-2-JavaScript-String-slice-方法"><a href="#1-2-JavaScript-String-slice-方法" class="headerlink" title="1.2 JavaScript String slice() 方法"></a>1.2 JavaScript String slice() 方法</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p><em>string</em>.slice(<em>start</em>,<em>end</em>)</p>
<h4 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>start</em></td>
<td align="left">必须。 要抽取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。</td>
</tr>
<tr>
<td align="left"><em>end</em></td>
<td align="left">可选。 紧接着要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。</td>
</tr>
</tbody></table>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">提取的字符串</td>
</tr>
</tbody></table>
<h2 id="2-replace"><a href="#2-replace" class="headerlink" title="2.replace"></a>2.replace</h2><p>支持字符串模式和正则表达式模式（支持全局和忽略大小写）</p>
<p><code>replace(/a/g, &#39;&#39;)</code> 去掉所有的a</p>
<h2 id="3-for-in-for-of"><a href="#3-for-in-for-of" class="headerlink" title="3.for in /for of"></a>3.for in /for of</h2><p>for in 遍历下标<br>for of 遍历值</p>
<h2 id="4-DATE相关"><a href="#4-DATE相关" class="headerlink" title="4.DATE相关"></a>4.DATE相关</h2><ul>
<li><p>Date.toLocaleString()时间戳转化成正常时间</p>
</li>
<li><p>Date.getDay()  星期几</p>
</li>
<li><p>Date.getMonth() 几月（要加一）</p>
</li>
</ul>
<h2 id="5-push和unshift"><a href="#5-push和unshift" class="headerlink" title="5.push和unshift"></a>5.push和unshift</h2><ul>
<li><p>push是加在末尾</p>
</li>
<li><p>unshift是加在第一个</p>
</li>
</ul>
<h2 id="6-类型数组"><a href="#6-类型数组" class="headerlink" title="6.类型数组"></a>6.类型数组</h2><p>  <img src="%E5%87%BD%E6%95%B0%E5%A4%87%E5%BF%98%E5%BD%95.assets/image-20201207204206410.png" alt="image-20201207204206410"></p>
<p>使用WebGI APi 、进行位操作、处理文件和图像时，类型数组都可以大展拳脚。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/12/es6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/12/es6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">es6笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-12 17:58:37" itemprop="dateCreated datePublished" datetime="2020-11-12T17:58:37+08:00">2020-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-01-16 17:14:34" itemprop="dateModified" datetime="2021-01-16T17:14:34+08:00">2021-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-js中的常量如果是对象，则对象中的值可以修改。"><a href="#1-js中的常量如果是对象，则对象中的值可以修改。" class="headerlink" title="1. js中的常量如果是对象，则对象中的值可以修改。"></a>1. js中的常量如果是对象，则对象中的值可以修改。</h3><p>const声明不允许修改绑定，但允许修改值。</p>
<p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const preson &#x3D; &#123;</span><br><span class="line">	name:&#39;mike&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;可以修改属性值</span><br><span class="line">person.name &#x3D; &#39;Greg&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;抛出错误</span><br><span class="line">person &#x3D; &#123;</span><br><span class="line">	name : &#39;Greg&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-重复元素在Set中自动被过滤"><a href="#2-重复元素在Set中自动被过滤" class="headerlink" title="2. 重复元素在Set中自动被过滤"></a>2. 重复元素在Set中自动被过滤</h3><h6 id="Set-对象"><a href="#Set-对象" class="headerlink" title="Set 对象"></a>Set 对象</h6><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<h6 id="Set-中的特殊值"><a href="#Set-中的特殊值" class="headerlink" title="Set 中的特殊值"></a>Set 中的特殊值</h6><p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<ul>
<li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</li>
<li>undefined 与 undefined 是恒等的，所以不重复；</li>
<li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复</li>
</ul>
<p>对象之间引用不同不恒等，即使值相同，Set 也能存储</p>
<h3 id="3-Uint8Array"><a href="#3-Uint8Array" class="headerlink" title="3. Uint8Array"></a>3. Uint8Array</h3><p><strong><code>Uint8Array</code></strong> 数组类型表示一个8位无符号整型数组，创建时内容被初始化为<strong>0</strong>。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Uint8Array(); &#x2F;&#x2F; ES2017 最新语法</span><br><span class="line">new Uint8Array(length); &#x2F;&#x2F; 创建初始化为0的，包含length个元素的无符号整型数组</span><br><span class="line">new Uint8Array(typedArray);</span><br><span class="line">new Uint8Array(object);</span><br><span class="line">new Uint8Array(buffer [, byteOffset [, length]]);</span><br></pre></td></tr></table></figure>

<h3 id="4-异步操作"><a href="#4-异步操作" class="headerlink" title="4. 异步操作"></a>4. 异步操作</h3><p>如果需要获取一个函数中异步操作的结果，则必须通过回调函数来获取。如setTimeout、readFile、writeFile、ajax</p>
<p>Promise本身不是异步，但是内部往往都是封装一个异步任务。</p>
<h3 id="5-Symbol"><a href="#5-Symbol" class="headerlink" title="5.Symbol"></a>5.Symbol</h3><p>Symbol 作为对象属性名时不能用.运算符，要用方括号。因为.运算符后面是字符串，所以取到的是字符串 sy 属性，而不是 Symbol 值 sy 属性。</p>
<h3 id="6-Class-类"><a href="#6-Class-类" class="headerlink" title="6.Class 类"></a>6.Class 类</h3><p>ES6 中规定，Class 内部只有静态方法，没有静态属性。</p>
<h3 id="7-Reflect-ownKeys-与Object-keys-区别"><a href="#7-Reflect-ownKeys-与Object-keys-区别" class="headerlink" title="7.Reflect.ownKeys()与Object.keys()区别"></a>7.Reflect.ownKeys()与Object.keys()区别</h3><p>Object.keys()主要用于遍历对象自有的可枚举属性，不包括继承自原型的属性和不可枚举的属性。<br>Reflect.ownKeys()返回所有自有属性key，不管是否可枚举，但不包括继承自原型的属性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/12/node-js%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/12/node-js%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">node.js笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-12 00:11:05" itemprop="dateCreated datePublished" datetime="2020-11-12T00:11:05+08:00">2020-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-21 14:52:42" itemprop="dateModified" datetime="2020-11-21T14:52:42+08:00">2020-11-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>在node中，没有全局作用域，只有模块作用域；外部访问不到内部，内部访问不到内部。</p>
</li>
<li><p>相对路径中的 ./ 不能省略，否则报错；</p>
</li>
<li><p>中文操作系统默认是gbk编码，服务器端发送的数据是utf8编码，所以中文会乱码</p>
</li>
<li><p>[JavaScript Standard Style] (http:// standardjs.com/)</p>
</li>
<li><p>当采用无分号的代码风格时，当一行代码是以：</p>
<p>（</p>
<p>   [</p>
<p>  `</p>
<p>开头的时候，则在前面补上一个分号以避免一些语法解析错误。所以无论你的代码是否有分号，都建议如果一行代码以（、[、`开头的，则最好在其前面补上分号。</p>
</li>
<li><p>客户端渲染不利于SEO搜索引擎优化；服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的；所以真正的网站都是两者结合来做的。</p>
<p>例如京东的商品列表就采用服务端渲染，目的是为了SEO搜索引擎优化，而它的商品评论列表为了用户体验，而且也不需要SEO优化，所以采用客户端渲染。</p>
</li>
<li><p>浏览器收到html响应内容之后，就要开始从上到下依次解析，当在解析过程中，如果发现：link\script\img\iframe\video\audio等带有src或者href（link）属性标签的时候，浏览器会自动对这些资源（一般存放在public文件中）发起新的请求。</p>
</li>
<li><p>CommonJS模块规范</p>
<p>加载<code>require</code></p>
<p>导出<code>exports</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多个成员(必须在对象中)</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">123</span></span><br><span class="line"><span class="built_in">exports</span>.b = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">//单个成员（拿到就是函数或者字符串）</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>node模块系统中，<code>exports</code>是<code>module.exports</code>的一个引用，最后return的是<code>module.exports</code></p>
</li>
<li><p>常用命令：</p>
<ul>
<li>npm init -y 跳过向导 快速生成</li>
<li>npm i  包名 -S  下载并保持依赖项</li>
<li>npm uninstall –save 包名   删除同时清除依赖项</li>
</ul>
</li>
<li><p>文件路径中的相对路径可以省略./ , 而模块加载中./不可以省。’/‘代表磁盘根目录，’./‘代表项目目录根路径。</p>
</li>
<li><p>get方法获取数据：<code>req.query</code></p>
<p>post方法获取数据：<code>req.body</code></p>
</li>
<li><p>从文件读取到的数据一定是字符串，所以一定要手动转换成对象</p>
<p><code>var students = JSON.parse(data).students</code></p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/08/%E6%97%A5%E5%B8%B8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/08/%E6%97%A5%E5%B8%B8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">日常技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-08 22:51:18 / 修改时间：22:54:32" itemprop="dateCreated datePublished" datetime="2020-11-08T22:51:18+08:00">2020-11-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、GitHub上查找开源项目"><a href="#1、GitHub上查找开源项目" class="headerlink" title="1、GitHub上查找开源项目"></a>1、GitHub上查找开源项目</h3><p>in:name example                  名字中有“example”<br>in:readme example        readme中有“example”<br>in:description example            描述中有“example”<br>stars:&gt;1000                             star&gt;1000<br>forks:&gt;1000                             fork&gt;1000<br>pushed:&gt;2019-09-01        2019年9月1日后有更新的<br>language:java                  用Java编写的项目</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/08/%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E8%B7%AF%E5%BE%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/2345.jpg">
      <meta itemprop="name" content="Johnson CHEN">
      <meta itemprop="description" content="The best time to plant a tree was twenty years ago. The second-best time is now. ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cpa To Coder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/08/%E5%89%8D%E7%AB%AF%E5%A4%8D%E4%B9%A0%E8%B7%AF%E5%BE%84/" class="post-title-link" itemprop="url">前端复习路径</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-08 20:37:14 / 修改时间：20:41:46" itemprop="dateCreated datePublished" datetime="2020-11-08T20:37:14+08:00">2020-11-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作者：程序员院长<br>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/555747?channel=1009&amp;source_id=home_feed">https://www.nowcoder.com/discuss/555747?channel=1009&amp;source_id=home_feed</a><br>来源：牛客网</p>
<p>一、打好基础不用说 </p>
<p> HTML、CSS、<a href="">JavaScript</a> 三大件，完全掌握。不懂得就直接查 MDN。 </p>
<p> HTML重点掌握语义化，区分块级和内联标签，其他查文档就好了，还有就是定义 head 里面一些meta 了解下。 </p>
<p> CSS重点看盒子模型，定位，层级，过渡，动画和 transform。知道原理和规则。大部分工作都是照着设计稿化。 </p>
<p> 掌握上面几个 99% 还原也不难。接下来重点学习几种常见的布局。 </p>
<p> 完了之后去搞flex。最后搞下sass、less。基本就差不多了。 </p>
<p> <a href="">JavaScript</a>。重点来了，红宝书看一遍掌握基础，进阶去看《你不知道的 <a href="">JavaScript</a>》。就这两套足够了，别搞那么多。 </p>
<p> 每个知识点搞懂。ES6 基本没啥问题。下面几个问题优先搞懂，优先级如下： </p>
<ul>
<li><p> this 用法，相关原理 </p>
</li>
<li><p> 原型/原型链 </p>
</li>
<li><p> 闭包 </p>
</li>
<li><p> 面向对象相关 </p>
</li>
<li><p> 同步异步/回调/promise/async、await </p>
</li>
<li><p>模块化 CommonJS, <a href="">AMD</a> </p>
<p>先搞这懂这些比较难的概念，对你JS理解更加深入。接下来在开始看框架方面： </p>
<p>二、框架方面 </p>
<p>前期要会用，后期要懂原理。 </p>
<p>新人先搞 Vue。Vue 算是上手容易的框架。照着官方文档来问题不大。原理方面要提高自己认识。学习怎么看<a href="">源码</a>。github常去逛逛。 </p>
<p>学习框架之前，我其实特别建议，新人先去了解 Babel 和 webpack 不仅仅是使用。一些原理方面的东西工作中也会用到。babel 里面会有教你如何编译代码。webpack 教你如和打包文件。自己手写编译器和打包工具也不是特别难。反正对之后看vue、react<a href="">源码</a>帮助挺大。 </p>
<p>搞完 Vue 全家桶，去了解下 React，React hooks 学习下新的理念。再回过头来看Vue。你会发现他们是如此的相似去又不同。 </p>
<p>多去实践总结，对整体框架理解会越来越深刻。 </p>
<p>新人刚开始看<a href="">源码</a>，会陷入两个困境中。一是无从下手。二是看了之后感觉没啥收获。 </p>
<p>这个也很正常。一般我们熟知的框架都有个几千甚至上万个PR。太大细节会干扰你。 </p>
<p>掌握整个节奏和流程。学习原理也比较吃力。就连找个入口都像大海捞针一样。建议从下面几个方面入手： </p>
</li>
</ul>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p> 挑简单的上手。别一开始就搞 vue、react、webpack。太难，会直接劝退新人。 </p>
<p> 不要为了面试而去读。反而效果不好，面试稍微问深入一点就答不出来了。平时有兴趣多琢磨琢磨。 </p>
<p> 按照难易程度：函数库 &lt; 组件库 &lt; 框架 &lt; 工程化 </p>
<p> 分别典型代表lodash &lt; vant &lt; vue &lt; webpack </p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p> 手撸简易模型。像vue, webpack, babel 都有简易<a href="">项目</a>给你撸。有的创始人（尤哥）还直播手撸。国外的更多，youtube 一搜一大堆。就算不看<a href="">源码</a>，照着写出了简易 demo 对原理和理解提升都是很大的。 </p>
<h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p> 调试开源<a href="">项目</a>。先把<a href="">项目</a>拉下来。在vscode里面跑下，核心函数多打几个断点。看看里面变量是怎么diff的。对理解更深刻了。看了<a href="">源码</a>是别人的，学到了是自己的。学习时候边记笔记，边思考原理，总结经验。下面来谈谈<a href="">前端</a>工程化怎么弄。 </p>
<p> 四、<a href="">前端</a>工程化 </p>
<p> 现在最流行的打包工具 webpack 用起来。当然直接用 vue-cli2、vue-cli3、create-react 都是可以的。但是 webpack 相关还是得掌握。 </p>
<p> 首先重点搞下babel、webpack。 </p>
<p> 学习下编译和打包的原理。 </p>
<p> 自己配置下 webpack。尝试自己去写下下 webpack 的 loader 和 plugin。 </p>
<p> 学习这些之前要懂一点 node.js， node.js 不需要全部学习。一般就日常用到读写文件fs接口，path 路径接口。这些 api 都不难写几个 demo 就懂了。基本上webpack 里面配置文件也没用到多少 node 的东西。最后自己学会配置 webpack 的配置文件。 </p>
<p> 如果想深想去优化打包体积和速度，就需要去了解很多webpack插件。webpack 里面最核心的就是插件了。 </p>
<p> 当然<a href="">前端</a>工程化不仅仅是这些，CI/CD可持续集成, Umi 了解下。sh各种脚本自动化命令、代码生成技术了解下。 </p>
<p> 五、性能优化的方案 </p>
<p> 一般来说。性能优化没什么系统化的文档供人学习。完全靠一些经验和自己的实践。 </p>
<p> 我们常提到性能好坏是由什么来衡量呢？ </p>
<p> 访问页面地址 –&gt; 页面首次加载数据 –&gt; 渲染出完整页面的时长 </p>
<p> 非首次情况下，命中缓存的加载缓存数据 –&gt; 渲染出完整页面的时长。 </p>
<p> 一般我从下面几个方面着手去做，一般问题都不大。 </p>
<h3 id="减小资源（静态资源，后端加载的数据）大小"><a href="#减小资源（静态资源，后端加载的数据）大小" class="headerlink" title="减小资源（静态资源，后端加载的数据）大小"></a>减小资源（静态资源，后端加载的数据）大小</h3><ul>
<li> 压缩代码HTML/CSS/JS </li>
<li> 压缩图片、音视频大小 </li>
<li> Tree-Sharking 消除无用代码 </li>
<li> 以上webpack都可以搞定 </li>
</ul>
<h3 id="避免同一时间的过多次数请求"><a href="#避免同一时间的过多次数请求" class="headerlink" title="避免同一时间的过多次数请求"></a>避免同一时间的过多次数请求</h3><ul>
<li> CSS 实现雪碧图：使用background-position共享一张图 </li>
<li> 图片懒加载：监听滚动后offsetTop, 使用data-src 替换 src（真实路径） </li>
<li> 列表懒加载（分批加载）：监听滚动后offsetTop， 发送请求加载下一页的数据 </li>
<li> 路由懒加载 </li>
<li> 代码分包分块加载（webpack） </li>
<li> 预加载技术 </li>
<li> 小程序分包、预下载等。 </li>
</ul>
<h3 id="利用缓存（空间换时间）"><a href="#利用缓存（空间换时间）" class="headerlink" title="利用缓存（空间换时间）"></a>利用缓存（空间换时间）</h3><p> CDN 内容分发：获取更近网络节点缓存下来的静态资源 浏览器缓存（自带） 部分资源保存在LocalStorage或者APP缓存中（手动操作） </p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p> SSR 服务端渲染：解决SPA框架带来JS动态渲染页面带来的延迟和白屏问题。 </p>
<p> 这些都可以去实践的，难度不大。 </p>
<p> 难度大的地方可能是 dom 节点成千上万的时候渲染的性能问题。 </p>
<p> 这个场景遇到的很少，方案很多。不同人有不同解决方案，有功夫可以自己去尝试尝试。 </p>
<p>  上面提到很多点都可以深入到很深。由于篇幅原因，点到即止。纯粹是把一些我以前走过的弯路掰直了再分享给大家。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Johnson CHEN"
      src="/images/2345.jpg">
  <p class="site-author-name" itemprop="name">Johnson CHEN</p>
  <div class="site-description" itemprop="description">The best time to plant a tree was twenty years ago. The second-best time is now. </div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Johnson CHEN</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
